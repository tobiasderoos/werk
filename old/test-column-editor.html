<!doctype html>
<html lang="nl">

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Editor transcriptie</title>
    <style>
        :root {
            --bg: #ffffff;
            --panel: #ffffff;
            --text: #1a1a1a;
            --muted: #666666;
            --line: #e5e5e5;
            --accent: #0066cc;
        }

        html,
        body {
            height: 100%;
            margin: 0;
            font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial;
            background: var(--bg);
            color: var(--text)
        }

        .app {
            padding: 16px;
            max-width: 1400px;
            margin: 0 auto
        }

        .panel {
            border: 1px solid var(--line);
            border-radius: 8px;
            background: var(--panel);
            overflow: hidden
        }

        .topbar {
            padding: 12px 16px;
            border-bottom: 1px solid var(--line);
            background: var(--panel);
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 12px
        }

        .title {
            font-weight: 800
        }

        .global-toolbar {
            display: flex;
            gap: 6px;
            flex-wrap: wrap
        }

        .grid-header {
            display: grid;
            grid-template-columns: 140px 160px 1fr;
            gap: 12px;
            padding: 10px 16px;
            border-bottom: 1px solid var(--line);
            background: var(--panel);
            font-size: 12px;
            color: var(--muted);
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: .05em
        }

        /* ✅ Row-based grid: heights stay aligned */
        .grid-body {
            max-height: calc(100vh - 200px);
            overflow: auto
        }

        .row {
            display: grid;
            grid-template-columns: 140px 160px 1fr;
            gap: 12px;
            align-items: stretch
        }

        .cell {
            min-height: 24px;
            padding: 10px 16px;
            border-bottom: 1px solid var(--line);
            line-height: 1.5;
            font-size: 14px
        }

        .timestamp-cell {
            font-variant-numeric: tabular-nums;
            color: var(--muted)
        }

        .speaker-cell {
            color: var(--text)
        }

        .text-cell {
            padding: 0;
            cursor: pointer
        }

        .text-cell:hover {
            background: #f5f5f5
        }

        .text-cell.editing {
            background: #f9f9f9;
            cursor: text
        }

        .text-cell .display {
            padding: 10px 16px
        }

        .text-cell .display p {
            margin: 0;
            min-height: 1.5em;
            line-height: 1.5
        }

        .text-cell .display p:empty::before {
            content: "\00a0";
            /* non-breaking space for empty lines */
            display: inline-block
        }

        .text-cell .ProseMirror {
            outline: none;
            padding: 10px 16px
        }

        .text-cell .ProseMirror p {
            margin: 0;
            min-height: 1.5em;
            line-height: 1.5
        }

        /* Empty paragraph placeholder so blank lines are visible */
        .text-cell .ProseMirror p:empty::before,
        .text-cell .ProseMirror p:has(br:only-child)::before {
            content: "";
            display: inline-block
        }

        .text-cell .ProseMirror strong {
            font-weight: 700;
            color: #000
        }

        .text-cell .ProseMirror em {
            font-style: italic
        }

        .text-cell .ProseMirror u {
            text-decoration: underline
        }

        .text-cell .ProseMirror s {
            text-decoration: line-through;
            opacity: .6
        }

        .row.highlight {
            background: #f0f8ff;
        }

        .row.highlight .cell {
            border-bottom-color: #d0e8ff;
        }

        .row[data-speaker="Spreker 1"] .speaker-cell {
            color: #5c6bc0;
            font-weight: 600;
        }

        .row[data-speaker="Spreker 2"] .speaker-cell {
            color: #8d6e63;
            font-weight: 600;
        }

        .row[data-speaker="Spreker 3"] .speaker-cell {
            color: #26a69a;
            font-weight: 600;
        }

        .row[data-speaker="Spreker 4"] .speaker-cell {
            color: #ec407a;
            font-weight: 600;
        }

        button {
            background: var(--panel);
            color: var(--text);
            border: 1px solid var(--line);
            padding: 6px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-weight: 500;
            font-size: 13px;
            transition: all .15s
        }

        button:hover {
            background: #f5f5f5;
            border-color: var(--muted)
        }

        button.active {
            background: var(--accent);
            color: #fff;
            border-color: var(--accent)
        }

        button.small {
            padding: 4px 10px;
            font-size: 12px
        }

        .hint {
            color: var(--muted);
            font-size: 12px;
            margin-top: 4px
        }
    </style>
</head>

<body>
    <div class="app">
        <div class="panel">
            <div class="topbar">
                <div class="title">Column Editor Transcript Grid</div>
                <div style="font-variant-numeric: tabular-nums; color: var(--muted); font-size: 14px;">
                    Time: <span id="currentTime">00:00:00.000</span>
                </div>
                <div class="global-toolbar" id="globalToolbar">
                    <button id="btnBold" class="small" tabindex="-1">Bold (⌘B)</button>
                    <button id="btnItalic" class="small" tabindex="-1">Italic (⌘I)</button>
                    <button id="btnUnderline" class="small" tabindex="-1">Underline (⌘U)</button>
                    <span style="border-left:1px solid var(--line);height:20px;margin:0 4px;"></span>
                    <button id="btnCopy" class="small" tabindex="-1">Copy with Formatting</button>
                    <span style="border-left:1px solid var(--line);height:20px;margin:0 4px;"></span>
                    <button id="btnUndo" class="small" tabindex="-1">Undo (⌘Z)</button>
                    <button id="btnRedo" class="small" tabindex="-1">Redo (⌘⇧Z)</button>
                </div>
            </div>

            <div class="grid-header">
                <div>Timestamp</div>
                <div>Spreker</div>
                <div>Tekst (klik om te editen)</div>
            </div>

            <!-- ✅ one container, rows are rendered inside -->
            <div class="grid-body" id="gridBody"></div>
        </div>

        <div class="hint" style="padding:12px;text-align:center;">
            Klik op een tekst cel om deze te bewerken. Wijzigingen worden automatisch opgeslagen.
        </div>
    </div>

    <script type="module">
        import { Editor } from "https://cdn.jsdelivr.net/npm/@tiptap/core@2.10.4/+esm";
        import StarterKit from "https://cdn.jsdelivr.net/npm/@tiptap/starter-kit@2.10.4/+esm";
        import Underline from "https://cdn.jsdelivr.net/npm/@tiptap/extension-underline@2.10.4/+esm";
        import { generateHTML } from "https://cdn.jsdelivr.net/npm/@tiptap/html@2.10.4/+esm";

        // ---------- Extensions (single source of truth) ----------
        const extensions = [
            StarterKit.configure({
                heading: false,
                bulletList: false,
                orderedList: false,
                blockquote: false,
                codeBlock: false,
                horizontalRule: false
            }),
            Underline,
        ];

        // ---------- Demo data ----------
        const pad2 = (n) => String(n).padStart(2, "0");
        const pad3 = (n) => String(n).padStart(3, "0");

        const INITIAL_ROWS = [
          {
            begin: "00:00:02.710",
            end: "00:00:05.230",
            speaker: "Spreker 2",
            begin_ms: 2710,
            end_ms: 5230,
            doc: { type: "doc", content: [{ type: "paragraph", content: [{ type: "text", text: "Hé heb je zin in poffertjes?" }] }] },
            html: null,
          },
          {
            begin: "00:00:05.590",
            end: "00:00:09.110",
            speaker: "Spreker 3",
            begin_ms: 5590,
            end_ms: 9110,
            doc: { type: "doc", content: [{ type: "paragraph", content: [{ type: "text", text: "Ja lekker ik lust wel poffertjes, waar wil je heen?" }] }] },
            html: null,
          },
          {
            begin: "00:00:09.990",
            end: "00:00:14.350",
            speaker: "Spreker 2",
            begin_ms: 9990,
            end_ms: 14350,
            doc: { type: "doc", content: [{ type: "paragraph", content: [{ type: "text", text: "Er is een nieuwe kraam op de markt. Ik heb gehoord dat ze daar lekkere poffertjes hebben." }] }] },
            html: null,
          },
          {
            begin: "00:00:14.750",
            end: "00:00:18.550",
            speaker: "Spreker 3",
            begin_ms: 14750,
            end_ms: 18550,
            doc: { type: "doc", content: [{ type: "paragraph", content: [{ type: "text", text: "Dat klinkt goed, Ik ga mee. Hoeveel poffertjes wil je?" }] }] },
            html: null,
          },
          {
            begin: "00:00:19.630",
            end: "00:00:21.590",
            speaker: "Spreker 2",
            begin_ms: 19630,
            end_ms: 21590,
            doc: { type: "doc", content: [{ type: "paragraph", content: [{ type: "text", text: "Ik denk 10 en jij?" }] }] },
            html: null,
          },
          {
            begin: "00:00:22.230",
            end: "00:00:25.790",
            speaker: "Spreker 3",
            begin_ms: 22230,
            end_ms: 25790,
            doc: { type: "doc", content: [{ type: "paragraph", content: [{ type: "text", text: "Ik ook en stroop nemen we stroop mee." }] }] },
            html: null,
          },
          {
            begin: "00:00:26.110",
            end: "00:00:29.390",
            speaker: "Spreker 2",
            begin_ms: 26110,
            end_ms: 29390,
            doc: { type: "doc", content: [{ type: "paragraph", content: [{ type: "text", text: "Ja, Dat is een goed idee. Ik pak even de stroop." }] }] },
            html: null,
          },
          {
            begin: "00:00:30.070",
            end: "00:00:32.870",
            speaker: "Spreker 3",
            begin_ms: 30070,
            end_ms: 32870,
            doc: { type: "doc", content: [{ type: "paragraph", content: [{ type: "text", text: "OK ik betaal ga jij alvast naar de kraam?" }] }] },
            html: null,
          },
          {
            begin: "00:00:33.470",
            end: "00:00:34.470",
            speaker: "Spreker 2",
            begin_ms: 33470,
            end_ms: 34470,
            doc: { type: "doc", content: [{ type: "paragraph", content: [{ type: "text", text: "Zal mij benieuwen?" }] }] },
            html: null,
          },
        ];

        function makeRowsFromInitial() {
            return INITIAL_ROWS.map(row => ({
                timestamp: row.begin,
                speaker: row.speaker,
                begin_ms: row.begin_ms,
                end_ms: row.end_ms,
                doc: JSON.parse(JSON.stringify(row.doc)),
                html: null
            }));
        }

        // Generate HTML from doc, with caching
        function getRowHTML(row) {
            if (!row.html) {
                row.html = generateHTML(row.doc, extensions);
            }
            return row.html;
        }

        // Create rows from initial data
        const rows = makeRowsFromInitial();

        // ---------- Rendering ----------
        const gridBody = document.getElementById("gridBody");

        function renderRow(i) {
            const row = rows[i];

            const rowEl = document.createElement("div");
            rowEl.className = "row";
            rowEl.dataset.index = String(i);
            rowEl.dataset.speaker = row.speaker;

            const ts = document.createElement("div");
            ts.className = "cell timestamp-cell";
            ts.textContent = row.timestamp;

            const sp = document.createElement("div");
            sp.className = "cell speaker-cell";
            sp.textContent = row.speaker;

            const tx = document.createElement("div");
            tx.className = "cell text-cell";
            tx.dataset.index = String(i);

            const display = document.createElement("div");
            display.className = "display";
            display.innerHTML = getRowHTML(row);
            tx.appendChild(display);

            tx.addEventListener("click", (e) => {
                e.stopPropagation();
                activateEditor(i, tx);
            });

            rowEl.appendChild(ts);
            rowEl.appendChild(sp);
            rowEl.appendChild(tx);

            return rowEl;
        }

        // initial render
        for (let i = 0; i < rows.length; i++) {
            gridBody.appendChild(renderRow(i));
        }

        // ---------- TipTap single active editor ----------
        let currentEditor = null;
        let currentIndex = null;
        let currentCell = null;

        function activateEditor(index, cell) {
            if (currentIndex === index && currentEditor) {
                currentEditor.commands.focus();
                return;
            }
            if (currentEditor) deactivateEditor();

            currentIndex = index;
            currentCell = cell;

            // replace display with editor host
            cell.classList.add("editing");
            cell.innerHTML = ""; // remove display
            const row = rows[index];

            const editor = new Editor({
                element: cell,
                extensions,
                content: row.doc,  // Load from JSON document
                onUpdate({ editor }) {
                    // Update the document model (source of truth)
                    row.doc = editor.getJSON();
                    row.html = null;  // Invalidate HTML cache
                }
            });

            currentEditor = editor;

            editor.on("selectionUpdate", updateToolbarState);
            editor.on("transaction", updateToolbarState);

            setTimeout(() => {
                editor.commands.focus("end");
                updateToolbarState();
            }, 0);
        }

        function deactivateEditor() {
            if (!currentEditor || currentIndex === null || !currentCell) return;

            const row = rows[currentIndex];
            // Save the document model (source of truth)
            row.doc = currentEditor.getJSON();
            row.html = null;  // Invalidate HTML cache

            currentEditor.destroy();
            currentEditor = null;

            // restore display
            currentCell.classList.remove("editing");
            const display = document.createElement("div");
            display.className = "display";
            display.innerHTML = getRowHTML(row);
            currentCell.innerHTML = "";
            currentCell.appendChild(display);

            currentIndex = null;
            currentCell = null;
        }

        // click outside to deactivate
        document.addEventListener("click", (e) => {
            if (!e.target.closest(".text-cell") && !e.target.closest(".global-toolbar")) {
                deactivateEditor();
            }
        });

        // ---------- Toolbar ----------
        function updateToolbarState() {
            if (!currentEditor) return;
            document.getElementById("btnBold").classList.toggle("active", currentEditor.isActive("bold"));
            document.getElementById("btnItalic").classList.toggle("active", currentEditor.isActive("italic"));
            document.getElementById("btnUnderline").classList.toggle("active", currentEditor.isActive("underline"));
        }

        // prevent toolbar stealing focus
        document.querySelectorAll(".global-toolbar button").forEach(btn => {
            btn.addEventListener("mousedown", (e) => e.preventDefault());
        });

        document.getElementById("btnBold").addEventListener("click", (e) => {
            e.stopPropagation(); if (!currentEditor) return;
            currentEditor.chain().focus().toggleBold().run();
            updateToolbarState();
        });

        document.getElementById("btnItalic").addEventListener("click", (e) => {
            e.stopPropagation(); if (!currentEditor) return;
            currentEditor.chain().focus().toggleItalic().run();
            updateToolbarState();
        });

        document.getElementById("btnUnderline").addEventListener("click", (e) => {
            e.stopPropagation(); if (!currentEditor) return;
            currentEditor.chain().focus().toggleUnderline().run();
            updateToolbarState();
        });

        document.getElementById("btnUndo").addEventListener("click", (e) => {
            e.stopPropagation(); if (!currentEditor) return;
            currentEditor.commands.undo();
            setTimeout(() => { currentEditor.commands.focus(); updateToolbarState(); }, 0);
        });

        document.getElementById("btnRedo").addEventListener("click", (e) => {
            e.stopPropagation(); if (!currentEditor) return;
            currentEditor.commands.redo();
            setTimeout(() => { currentEditor.commands.focus(); updateToolbarState(); }, 0);
        });

        // ---------- Copy with formatting (fixed HTML nesting) ----------
        function htmlToText(html) {
            const div = document.createElement("div");
            div.innerHTML = html || "";
            return (div.textContent || "").trim();
        }

        document.getElementById("btnCopy").addEventListener("click", async (e) => {
            e.stopPropagation();
            try {
                let formattedText = "";
                let htmlContent = "";

                // Speaker color mapping
                const speakerColors = {
                    "Spreker 1": "#5c6bc0",
                    "Spreker 2": "#8d6e63",
                    "Spreker 3": "#26a69a",
                    "Spreker 4": "#ec407a"
                };

                rows.forEach((row) => {
                    const html = getRowHTML(row);
                    const plain = htmlToText(html);
                    formattedText += `${row.timestamp} - ${row.speaker}: ${plain}\n`;
                    const speakerColor = speakerColors[row.speaker] || "#1a1a1a";
                    htmlContent += `
                        <div style="margin:0 0 6px 0;">
              ${row.timestamp} - <span style="color:${speakerColor};font-weight:600;">${row.speaker}</span>:
              ${html}
            </div>`;
                });

                await navigator.clipboard.write([
                    new ClipboardItem({
                        "text/html": new Blob([htmlContent], { type: "text/html" }),
                        "text/plain": new Blob([formattedText], { type: "text/plain" }),
                    })
                ]);

                alert("Transcript copied with formatting!");
            } catch (err) {
                console.error("Failed to copy:", err);
                alert("Failed to copy. Please try again.");
            }
        });

        console.log("Grid rendered with", rows.length, "rows");

        // ---------- Fake timer with row highlighting ----------
        let currentMs = 0;
        let highlightedRow = null;

        function updateTimer() {
            // Increment time by 100ms for smoother updates
            currentMs += 100;

            // Convert to timestamp format
            const totalSeconds = Math.floor(currentMs / 1000);
            const hours = Math.floor(totalSeconds / 3600);
            const minutes = Math.floor((totalSeconds % 3600) / 60);
            const seconds = totalSeconds % 60;
            const ms = currentMs % 1000;

            const timeString = `${pad2(hours)}:${pad2(minutes)}:${pad2(seconds)}.${pad3(ms)}`;
            document.getElementById("currentTime").textContent = timeString;

            // Find the row that should be highlighted based on current time
            // Use begin_ms and end_ms for precise matching
            let rowToHighlight = null;
            for (let i = 0; i < rows.length; i++) {
                const row = rows[i];
                if (row.begin_ms !== undefined && row.end_ms !== undefined) {
                    if (currentMs >= row.begin_ms && currentMs < row.end_ms) {
                        rowToHighlight = i;
                        break;
                    }
                }
            }

            // Update highlighting
            if (rowToHighlight !== highlightedRow) {
                // Remove old highlight
                if (highlightedRow !== null) {
                    const oldRow = gridBody.querySelector(`.row[data-index="${highlightedRow}"]`);
                    if (oldRow) oldRow.classList.remove("highlight");
                }

                // Add new highlight
                if (rowToHighlight !== null) {
                    const newRow = gridBody.querySelector(`.row[data-index="${rowToHighlight}"]`);
                    if (newRow) {
                        newRow.classList.add("highlight");
                        // Scroll into view
                        newRow.scrollIntoView({ behavior: "smooth", block: "center" });
                    }
                }

                highlightedRow = rowToHighlight;
            }
        }

        // Start the timer (100ms intervals for smoother highlighting)
        setInterval(updateTimer, 100);
    </script>
</body>

</html>
